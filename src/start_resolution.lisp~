;(cd #P"C:/Users/Tobias/Documents/Lisp/cl-reason/src/")
;(get-current-directory)

(if (not (require 'asdf)) 
    (load (merge-pathnames "../lib/asdf" *load-truename*))
)
(load (current-pathname "../lib/cl-ppcre-2.0.9/cl-ppcre.asd"))
(load (current-pathname "../lib/cl-yacc-20101006-darcs/yacc.asd"))

(load (merge-pathnames "init" *load-truename*))
(load (merge-pathnames "util/util" *load-truename*))
(load (merge-pathnames "parser/lexer" *load-truename*))
(load (merge-pathnames "parser/parser" *load-truename*))
(load (merge-pathnames "predicates/predicates" *load-truename*))
(load (merge-pathnames "logik/resolution" *load-truename*))
(load (merge-pathnames "gui/GUI" *load-truename*))

; zeug zum testen und für schöne ausgabe
(setq file-path (merge-pathnames "../test/test_pred2.clr" *load-truename*))

(run)

(defun run () 


(predicates:setup-predicates )
(setq folder (directory (merge-pathnames "../predicates/*.*" *load-truename*)))
(predicates:load-predicates folder)
(predicates:get-clause-predicates)

(setq liste (first (resolution:run-program file-path)))

(mapcar (lambda(x) 
	(mapcar 'calc-result x)
	) liste)
)

(defun calc-result (result)
	(print result)
	(let ((type (get result 'resolution::type)))
          (print type)
		(cond ((equal type 'variable) (get result 'resolution::name))
                      ((equal type 'function) (eval-fun result))
                      ((equal type 'parser::const) (get result 'resolution::name))
			  )
	)
)


(defun check-fun-args-const (fun)
	(let* ((operator (get fun 'lexer:name))
		(result (mapcar (lambda (argument) 
				(let ((type (get argument 'type)))
					(cond ((equal type 'function) (check-fun-args-const argument))
						  ((equal type 'parser::const) T)
						  (T (progn (print (list "fail" argument type)) (return-from check-fun-args-const NIL)))
					)
				)
			)
		(get fun 'lexer:args))))
		(mapcar (lambda (x) (if (not x) (return-from check-fun-args-const NIL))) result)
		(return-from check-fun-args-const T)
	)
)

(defun is-arith-fun (fun)
	(let* ((operator (get fun 'lexer:name))
		(result (cond ((string-equal operator "+") T) 
			(T NIL))))
	;	(print (list "is-arith-fun:" result))
		result
	)
)

(defun eval-fun (fun)
	(let ((operator (get fun 'lexer::name))
		(number-list (mapcar (lambda (argument) 
			;	(print (list "argument:" argument))
				(let ((type (get argument 'type))
					  (nvalue (get argument 'parser::value)))
					(cond ((not nvalue) (setq nvalue (get argument 'parser::name)))
						 (T NIL))
					(print (list "value: " nvalue))
					(cond ((equal type 'function) (eval-fun argument))
						  ((equal type 'parser::const) nvalue)
						  (T NIL)
					)
				)
			)
		(get fun 'lexer:args))))
		(cond ((string-equal operator "+") 
			(apply '+ number-list))
                      ((string-equal operator "cons")
                        (apply 'cons number-list))
			(T NIL))
	)
)
