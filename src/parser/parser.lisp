(asdf:operate 'asdf:load-op :yacc)

(defpackage :parser
  (:use :common-lisp :lexer :util :yacc)
  (:export :parse-file
	   :pos-lit :neg-lits :vars :prog-clause :goal-clause :const))

(in-package :parser)

(defun parse-file (path)
  (mapcar 'reverse-neg-lits (interpret-symbols-in-clauses (parse-program (lex-file path)))))

(defun parse-program (input)
  (do* ((ntl '(s))
	(program input)
	(output NIL)
	(la (take 2 program) (take 2 program))
	(expansion (funcall (next-nt ntl) la) (funcall (next-nt ntl) la))
	(production (nth 2 expansion) (nth 2 expansion))
	(to-match (car expansion) (car expansion))
	(new-nt (cadr expansion) (cadr expansion)))
       ((and (not program) (not ntl)) (reverse output))
    (case production
      (0 (setq output (cons (new-clause) output)))
      (1 (setq output (cons (new-clause 'goal) output)))
      (2 (progn (setq output (cons (new-clause) output))
		(setf (get (car output) 'pos-lit) (parse-terms-in-lit (car program)))))
      (3 nil)
      (4 (setf (get (car output) 'vars) (cons (car program) (get (car output) 'vars))))
      (5 (setf (get (car output) 'vars) (reverse (cons (car program)
						       (get (car output) 'vars)))))
      (6 (setf (get (car output) 'pos-lit) (parse-terms-in-lit (car program))))
      (7 (setf (get (car output) 'neg-lits) (cons (parse-terms-in-lit (car program))
						  (get (car output) 'neg-lits))))
      (8 (setf (get (car output) 'pos-lit) (parse-terms-in-lit (car program))))
      (9 nil)
      (11 (progn (setf (get (car output) 'neg-lits)
		       (cons (parse-terms-in-lit (car program))
			     (get (car output) 'neg-lits)))
		 (setf (get (car output) 'pos-lit) (parse-terms-in-lit (caddr program))))))
    (setq program (match (car expansion) program))
    (setq ntl (append (cadr expansion) (cdr ntl)))))

(defun match (x input)
  (let ((match_length (length x)))
    (cond ((la-check (take match_length input) x)
	   (subseq input match_length))
	  (T (error "match error")))))

(defun s (la)
  (cond ((la-check la '(forall var))
	 '((forall) (v k s) 0))
	((la-check la '(exists var))
	 '((exists) (v k s) 1))
	((la-check la '(lit end))
	 '((lit end) (s) 2))
	((la-check la NIL)
	 '(nil nil 3))
	(T (error "no fitting production"))))

(defun v (la)
  (cond ((la-check la '(var var))
	 '((var) (v) 4))
	((la-check la '(var in))
	 '((var in) nil 5))
	(T (error "no fitting production"))))

(defun k (la)
  (cond ((la-check la '(lit <=))
	 '((lit <=) (f) 6))
	((la-check la '(lit and))
	 '((lit and) (f2) 7))
	((la-check la '(lit end))
	 '((lit end) nil 8))
	((la-check la '(lit =>))
	 '(() (f) 9))
	(T (error "no fitting production"))))

(defun f (la)
  (cond ((la-check la '(lit end))
	 '((lit end) nil 7))
	((la-check la '(lit and))
	 '((lit and) (f) 7))
	(T (error "no fitting production"))))

(defun f2 (la)
  (cond ((la-check la '(lit end))
	 '((lit end) nil 7))
	((la-check la '(lit =>))
	 '((lit => lit end) nil 11))
	((la-check la '(lit and))
	 '((lit and) (f) 7))
	(T (error "no fitting production"))))

(defun next-nt (l)
  (cond ((not l) (lambda (x) x))
	(t (car l))))

(defun la-check (la match)
  (let ((new-la (mapcar 'symbol-value la)))
    (equal new-la match)))

(defun new-clause (&optional (clause-type 'program))
  (let ((sym (gensym "clause-")))
    (import sym)
    (case clause-type
      (program (setf (get sym 'type) 'prog-clause))
      (goal (setf (get sym 'type) 'goal-clause)))
    sym))

(defun reverse-neg-lits (clause)
  (setf (get clause 'neg-lits)
	(reverse (get clause 'neg-lits)))
  clause)

;;;--- Term parser -----------------------------------------------------------
;;; test-terme: P(x,3 + 123,[f|r],y)
(defvar test-terme '(LB AND LB NOT LB X RB SEP Y RB SEP ERG RB))

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defun i2p (a b c)
    "Infix to prefix"
    (list b a c))
  
  (defun k-2-3 (a b c)
    "Second out of three"
    (declare (ignore a c))
    b)

  (defun ignore-sec (a b c)
    (declare (ignore b))
    (list a c))

  (defun define-arith (a1 op a2)
    (let ((sym (gensym "ae-")))
      (import sym)
      (setf (get sym 'type) 'arith-exp)
      (setf (get sym 'args) (list a1 a2))
      (setf (get sym 'name) (write-to-string op))
      (setf (get sym 'exp) (list op a1 a2))
      sym))

  (defun define-concrete-list (a elems b)
    (declare (ignore a b))
    (let ((sym (gensym "list-")))
      (import sym)
      (setf (get sym 'name) "cons")
      (setf (get sym 'type) 'concrete-list)
      (setf (get sym 'elems) elems)
      sym))

  (defun define-abstract-list (a elem b rest c)
    (let ((sym (gensym "list-")))
      (import sym)
      (setf (symbol-value sym) (list a elem b rest c))
      (setf (get sym 'name) "cons")
      (setf (get sym 'type) 'abstract-list)
      (setf (get sym 'first) elem)
      (setf (get sym 'rest) rest)
      (setf (get sym 'args) (list elem rest))
      ;;(setf (get sym 'elems) (list elem rest))
      sym))

  (defun define-sym-fun (name x args y)
    (declare (ignore x y))
    (let ((sym (gensym "fun-")))
      (import sym)
      (setf (get sym 'type) 'function)
      (setf (get sym 'name) (string-downcase (write-to-string name)))
      (setf (get sym 'args) (condense-terms args))
      sym)))

(define-parser *term-parser*
  (:start-symbol S)
  (:terminals (LB RB LS CONS LE + - * / SEP INT SYM))
  (:precedence ((:left * /) (:left + -)))
  (s (LB t RB #'k-2-3))
  (t SYM
     a
     l
     f
     (t SEP t #'ignore-sec)
     ())
  (a (a + a #'define-arith)
     (a - a #'define-arith)
     (a * a #'define-arith)
     (a / a #'define-arith)
     (LB a RB #'k-2-3)
     SYM
     INT)
  (f (SYM LB t RB #'define-sym-fun))
  (l (LS t LE #'define-concrete-list)
     (LS SYM CONS SYM LE #'define-abstract-list)
     (LS SYM CONS l LE #'define-abstract-list)))

(defun condense-terms (term-list)
  (cond ((atom term-list) (list term-list))
	((notany 'listp term-list) term-list)
	(T (cons (car term-list) (condense-terms (cadr term-list))))))

(defun parse-terms-in-lit (lit)
  (let ((term-list (get lit 'args)))
    (setf (get lit 'args) (condense-terms
			   (parse-with-lexer (make-term-lexer term-list)
					     *term-parser*)))
    lit))

;;; ---- Interpreter ---------------------------------------------------------

(defun var-member (sym vars)
  (member sym vars :test (lambda (x y) (equal x (read-from-string (get y 'name))))))

;; (setq test-clause (nth 0 (parse-file path)))
;; (setq test-lit (get test-clause 'pos-lit))
;; (setq test-lit2 (cadr (get test-clause 'neg-lits)))
;; (setq test-list (car (get test-lit 'args)))
;; (setq vars (get (car (parse-file path)) 'vars))
(defun interpret-symbols-in-clauses (clauses)
  (mapc (lambda (clause)
	  (let ((vars (get clause 'vars))
		(pos-lit (get clause 'pos-lit))
		(neg-lits (get clause 'neg-lits)))
	    (when pos-lit (interpret-symbols-in-lit pos-lit vars))
	    (when neg-lits (mapc (lambda (x)
				   (interpret-symbols-in-lit x vars))
				 neg-lits))))
	clauses))

;; (setq clause (car (parse-program (lex-file path))))
;; (setq vars (get clause 'vars))
;; (setq lit (car (get clause 'neg-lits)))
;; (setq x (car (get lit 'args)))
(defun interpret-symbols-in-lit (lit vars)
  (setf (get lit 'args)
	(mapcar (lambda (x)
		  (cond ((and (atom x)
			      (var-member x vars))
			 (car (var-member x vars)))
			((numberp x) (let ((sym (gensym "const-")))
				       (import sym)
				       (setf (get sym 'type) 'const)
				       (setf (get sym 'name)
					     (concatenate 'string
							  "number-"
							  (write-to-string x)))
				       (setf (get sym 'value) x)
				       sym))
			((equal (get x 'type) 'function)
			 (interpret-symbols-in-lit x vars))
			((or (equal (get x 'type) 'concrete-list)
			     (equal (get x 'type) 'abstract-list))
			 (interpret-symbols-in-lit (interpret-list x) vars))
			((equal (get x 'type) 'arith-exp)
			 (interpret-symbols-in-lit x vars))
			((equal (get x 'type) 'const) x)
			((atom x) (let ((sym (gensym "const-")))
				    (import sym)
				    (setf (get sym 'type) 'const)
				    (setf (get sym 'name)
					  (string-downcase (write-to-string x)))
				    sym))
			(T x)))
		(if (listp (get lit 'args))
		    (get lit 'args)
		  (list (get lit 'args)))))
  lit)

(defun interpret-list (list-sym)
  (let ((listtype (get list-sym 'type))
	(elems (get list-sym 'elems)))
    (cond ((equal listtype 'abstract-list)
	   (progn (setf (get list-sym 'type) 'function)
		  list-sym))
	  ((not elems) (empty-list))
	  ((equal listtype 'concrete-list)
	   (progn
	     (setf (get list-sym 'args) (translate-elems elems))
	     (setf (get list-sym 'type) 'function)
	     list-sym)))))

(defun def-list (elems)
  (let ((sym (gensym "list-")))
    (import sym)
    (setf (get sym 'type) 'function)
    (setf (get sym 'name) "cons")
    (setf (get sym 'args) elems)
    sym))

(defun empty-list ()
  (let ((sym (gensym "const-")))
    (import sym)
    (setf (get sym 'type) 'const)
    (setf (get sym 'name) "empty")
    sym))

(defun translate-elems (elems)
  (cond ((atom elems) (list elems (empty-list)))
	((= 1 (length elems)) (list (car elems) (empty-list)))
	(T (list (car elems) (def-list (translate-elems (cadr elems)))))))
